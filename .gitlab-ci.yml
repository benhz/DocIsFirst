# 只在 main 分支触发整个流水线
workflow:
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
      when: always
    - when: never

stages:
  - install
  - test
  - build
  - docker
  - deploy

# 默认使用内网的 Node 镜像
image: tool-1:5000/library/node:24.11.1

# 镜像相关变量
variables:
  IMAGE_REGISTRY: "tool-1:5000"
  IMAGE_NAME: "library/docusaurus-docs"
  IMAGE_TAG: "$CI_COMMIT_SHORT_SHA"

# 缓存 node_modules 和 yarn 缓存
cache:
  key: ${CI_COMMIT_REF_SLUG}
  paths:
    - node_modules/
    - .yarn/cache/

# ==================== 安装依赖 ====================
install:
  stage: install
  tags:
    - Upward-always
  script:
    - echo "install dependencies"
    - yarn install --frozen-lockfile
  artifacts:
    paths:
      - node_modules/
    expire_in: 1 day

# ==================== 类型检查 ====================
typecheck:
  stage: test
  tags:
    - Upward-always
  dependencies:
    - install
  script:
    - echo "run typecheck"
    - yarn typecheck

# ==================== 构建项目 ====================
build:
  stage: build
  tags:
    - Upward-always
  dependencies:
    - install
  script:
    - echo "build project"
    - yarn build
  artifacts:
    paths:
      - build/
    expire_in: 7 days

# ==================== Docker 构建和推送（Kaniko） ====================
docker_build:
  stage: docker
  tags:
    - Upward-always
  image:
    name: tool-1:5000/gcr.io/kaniko-project/executor:debug
    entrypoint: [""]
  variables:
    IMAGE: "${IMAGE_REGISTRY}/${IMAGE_NAME}:${IMAGE_TAG}"
    DOCKER_CONFIG: "/kaniko/.docker"
  dependencies:
    - build
  script:
    - echo "build and push image ${IMAGE}"
    - mkdir -p /kaniko/.docker
    # 用 CI 变量里的 admin 账号生成 Harbor 登录信息
    - AUTH=$(printf "%s:%s" "$HARBOR_USER" "$HARBOR_PASSWORD" | base64 | tr -d '\n')
    - echo "{\"auths\":{\"tool-1:5000\":{\"auth\":\"$AUTH\"}}}" > /kaniko/.docker/config.json
    # 这里注意：不要再加 --docker-config
    - /kaniko/executor --context=. --dockerfile=Dockerfile --destination=${IMAGE} --skip-tls-verify-registry=tool-1:5000
  only:
    - main

# ==================== 部署到 K3s ====================
deploy_k8s:
  stage: deploy
  tags:
    - Upward-always
  image: tool-1:5000/bitnami/kubectl:latest
  dependencies:
    - docker_build
  script:
    - echo "deploy to k3s"
    - kubectl version --client
    # 1. namespace（已经有也没事，多 apply 一次是幂等的）
    # - kubectl apply -f k8s/00-namespace.yaml || true
    # 2. deployment：用当前 IMAGE_TAG 替换占位符再 apply
    - sed "s/\${IMAGE_TAG}/${IMAGE_TAG}/g" k8s/30-deployment.yaml | kubectl apply -f -
    # 3. service：直接 apply
    - kubectl apply -f k8s/40-service.yaml
    # 4. 等 deployment 滚动完成
    - kubectl rollout status deployment/docusaurus -n platform-docs --timeout=5m
    - echo "deploy done"
  only:
    - main
